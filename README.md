# text-device

# задание

Требуется реализовать драйвер, поддерживающий функции открытия, закрытия, записи, чтения и имеющий документацию. При записи в драйвер могут передаваться команды. Для этого нужно проводить общий анализ передаваемых в него строк, чтобы определять какие команды передаются. Одна из них direction [forward/back] – направление дальнейшего чтения из драйвера.

f) Драйвер поддерживает чтение файла в формате ASCII и запись сообщений в него через пользовательский процесс: ioctl_set_msg(file_desc, msg). Поддерживает функцию удаления сообщения: ioctl_msg_delete.

# решение
1. мне изветно как работают системные вызовы read, write, ioctl, поэтому я смог их (сам, для своего устройства) реализовать и поместить в file_operations.
2. эти вызовы работают со строкой, доступной этому драйверу из глобальной области
3. работа со строкой зависит от того является ли она командой смены направления и того какое сейчас направление в ином случае
4. для считывания особой ситуации когда подается команда - написать отдельный модуль языка Си в котором есть функция int handle_command(char* str)
5. для удаления текущей строки добавить константу ioctl IOCTL_DELETE_MSG

возникшие сложности и пути их решения:

- неправильное представление строк в стиле си при чтении назад.

    решение: добавить искусственную отправку нулевого байта

# использование

```sh
make -C /usr/src/linux-headers-5.15.0-76-generic M=$PWD modules # для сборки драйвера нужны заголовки ядра. здесь я взял те что лежали у меня на пк
sudo insmod ./text-device.ko # загрузка собранного драйвера в память
sudo mknod my_char_dev c 100 0 # создание устройства для этого драйвера
# use.c содержит вызов ioctl-ных запросов к устройству my_char_dev в текущей директории. можно проверить их работу прочитав что лежит в my_char_dev:
gcc use.c 
./a.out
cat my_char_dev
```
